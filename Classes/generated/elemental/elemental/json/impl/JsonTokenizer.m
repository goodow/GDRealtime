//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: src/elemental/json/impl/JsonTokenizer.java
//
//  Created by retechretech on 13-5-25.
//

#import "IOSCharArray.h"
#import "elemental/json/JsonArray.h"
#import "elemental/json/JsonBoolean.h"
#import "elemental/json/JsonException.h"
#import "elemental/json/JsonFactory.h"
#import "elemental/json/JsonNull.h"
#import "elemental/json/JsonNumber.h"
#import "elemental/json/JsonObject.h"
#import "elemental/json/JsonString.h"
#import "elemental/json/JsonValue.h"
#import "elemental/json/impl/JreJsonFactory.h"
#import "elemental/json/impl/JsonTokenizer.h"
#import "java/lang/Character.h"
#import "java/lang/Double.h"
#import "java/lang/Integer.h"
#import "java/lang/Math.h"
#import "java/lang/NumberFormatException.h"
#import "java/lang/StringBuffer.h"
#import "java/lang/System.h"

@implementation ElementalJsonImplJsonTokenizer

static NSString * ElementalJsonImplJsonTokenizer_STOPCHARS_ = @",:]}/\\\"[{;=#";

- (id<EMJsonFactory>)jsonFactory {
  return jsonFactory_;
}
- (void)setJsonFactory:(id<EMJsonFactory>)jsonFactory {
  JreOperatorRetainedAssign(&jsonFactory_, jsonFactory);
}
@synthesize jsonFactory = jsonFactory_;
@synthesize lenient = lenient_;
@synthesize pushBackBuffer = pushBackBuffer_;
- (NSString *)json {
  return json_;
}
- (void)setJson:(NSString *)json {
  JreOperatorRetainedAssign(&json_, json);
}
@synthesize json = json_;
@synthesize position = position_;

+ (NSString *)STOPCHARS {
  return ElementalJsonImplJsonTokenizer_STOPCHARS_;
}

- (id)initWithElementalJsonImplJreJsonFactory:(ElementalJsonImplJreJsonFactory *)serverJsonFactory
                                 withNSString:(NSString *)json {
  if ((self = [super init])) {
    lenient_ = YES;
    pushBackBuffer_ = ElementalJsonImplJsonTokenizer_INVALID_CHAR;
    position_ = 0;
    self.jsonFactory = serverJsonFactory;
    self.json = json;
  }
  return self;
}

- (void)backWithUnichar:(unichar)c {
  NSAssert(pushBackBuffer_ == ElementalJsonImplJsonTokenizer_INVALID_CHAR, @"src/elemental/json/impl/JsonTokenizer.java:50 condition failed: assert pushBackBuffer == INVALID_CHAR;");
  pushBackBuffer_ = c;
}

- (void)backWithInt:(int)c {
  [self backWithUnichar:(unichar) c];
}

- (int)next {
  if (pushBackBuffer_ != ElementalJsonImplJsonTokenizer_INVALID_CHAR) {
    int c = pushBackBuffer_;
    pushBackBuffer_ = ElementalJsonImplJsonTokenizer_INVALID_CHAR;
    return c;
  }
  return position_ < [NIL_CHK(json_) length] ? [NIL_CHK(json_) charAtWithInt:position_++] : ElementalJsonImplJsonTokenizer_INVALID_CHAR;
}

- (NSString *)nextWithInt:(int)n {
  if (n == 0) {
    return @"";
  }
  IOSCharArray *buffer = [[[IOSCharArray alloc] initWithLength:n] autorelease];
  int pos = 0;
  if (pushBackBuffer_ != ElementalJsonImplJsonTokenizer_INVALID_CHAR) {
    [((IOSCharArray *) NIL_CHK(buffer)) replaceCharAtIndex:0 withChar:(unichar) pushBackBuffer_];
    pos = 1;
    pushBackBuffer_ = ElementalJsonImplJsonTokenizer_INVALID_CHAR;
  }
  int len;
  while ((pos < n) && ((len = [self readWithJavaLangCharacterArray:buffer withInt:pos withInt:n - pos]) != -1)) {
    pos += len;
  }
  if (pos < n) {
    @throw [[[EMJsonException alloc] initWithNSString:@"TODO"] autorelease];
  }
  return [NSString valueOfChars:buffer];
}

- (int)nextNonWhitespace {
  while (YES) {
    int c = [self next];
    if (![JavaLangCharacter isSpaceWithUnichar:(unichar) c]) {
      return c;
    }
  }
}

- (NSString *)nextStringWithInt:(int)startChar {
  JavaLangStringBuffer *buffer = [[[JavaLangStringBuffer alloc] init] autorelease];
  int c = [self next];
  NSAssert(c == ElementalJsonImplJsonTokenizer_DOUBLE_QUOTE || (lenient_ && c == ElementalJsonImplJsonTokenizer_SINGLE_QUOTE), @"src/elemental/json/impl/JsonTokenizer.java:109 condition failed: assert c == DOUBLE_QUOTE || (lenient && c == SINGLE_QUOTE);");
  while (YES) {
    c = [self next];
    switch (c) {
      case 0x000d:
      case 0x000a:
      @throw [[[EMJsonException alloc] initWithNSString:@""] autorelease];
      case '\\':
      c = [self next];
      switch (c) {
        case 'b':
        [((JavaLangStringBuffer *) NIL_CHK(buffer)) appendWithUnichar:0x0008];
        break;
        case 't':
        [((JavaLangStringBuffer *) NIL_CHK(buffer)) appendWithUnichar:0x0009];
        break;
        case 'n':
        [((JavaLangStringBuffer *) NIL_CHK(buffer)) appendWithUnichar:0x000a];
        break;
        case 'f':
        [((JavaLangStringBuffer *) NIL_CHK(buffer)) appendWithUnichar:0x000c];
        break;
        case 'r':
        [((JavaLangStringBuffer *) NIL_CHK(buffer)) appendWithUnichar:0x000d];
        break;
        case 'u':
        [((JavaLangStringBuffer *) NIL_CHK(buffer)) appendWithUnichar:(unichar) [JavaLangInteger parseIntWithNSString:[self nextWithInt:4] withInt:16]];
        break;
        default:
        [((JavaLangStringBuffer *) NIL_CHK(buffer)) appendWithUnichar:(unichar) c];
      }
      break;
      default:
      if (c == startChar) {
        return [((JavaLangStringBuffer *) NIL_CHK(buffer)) description];
      }
      [((JavaLangStringBuffer *) NIL_CHK(buffer)) appendWithUnichar:(unichar) c];
    }
  }
}

- (NSString *)nextUntilOneOfWithNSString:(NSString *)chars {
  JavaLangStringBuffer *buffer = [[[JavaLangStringBuffer alloc] init] autorelease];
  int c = [self next];
  while (c != ElementalJsonImplJsonTokenizer_INVALID_CHAR) {
    if ([JavaLangCharacter isSpaceWithUnichar:(unichar) c] || [NIL_CHK(chars) indexOf:(unichar) c] >= 0) {
      [self backWithInt:c];
      break;
    }
    [((JavaLangStringBuffer *) NIL_CHK(buffer)) appendWithUnichar:(unichar) c];
    c = [self next];
  }
  return [((JavaLangStringBuffer *) NIL_CHK(buffer)) description];
}

- (id)nextValue {
  int c = [self nextNonWhitespace];
  [self backWithInt:c];
  switch (c) {
    case '"':
    case '\'':
    return (id) [((id<EMJsonFactory>) NIL_CHK(jsonFactory_)) createWithNSString:[self nextStringWithInt:c]];
    case '{':
    return (id) [self parseObject];
    case '[':
    return (id) [self parseArray];
    default:
    return (id) [self getValueForLiteralWithNSString:[self nextUntilOneOfWithNSString:ElementalJsonImplJsonTokenizer_STOPCHARS_]];
  }
}

- (id<EMJsonArray>)parseArray {
  id<EMJsonArray> array = [((id<EMJsonFactory>) NIL_CHK(jsonFactory_)) createArray];
  int c = [self nextNonWhitespace];
  NSAssert(c == '[', @"src/elemental/json/impl/JsonTokenizer.java:185 condition failed: assert c == '[';");
  while (YES) {
    c = [self nextNonWhitespace];
    switch (c) {
      int d;
      case ']':
      return array;
      default:
      [self backWithInt:c];
      [((id<EMJsonArray>) NIL_CHK(array)) setWithInt:[((id<EMJsonArray>) NIL_CHK(array)) length] withEMJsonValue:[self nextValue]];
      d = [self nextNonWhitespace];
      switch (d) {
        case ']':
        return array;
        case ',':
        break;
        default:
        @throw [[[EMJsonException alloc] initWithNSString:@"Invalid array: expected , or ]"] autorelease];
      }
    }
  }
}

- (id<EMJsonObject>)parseObject {
  id<EMJsonObject> object = [((id<EMJsonFactory>) NIL_CHK(jsonFactory_)) createObject];
  int c = [self nextNonWhitespace];
  if (c != '{') {
    @throw [[[EMJsonException alloc] initWithNSString:[NSString stringWithFormat:@"Payload does not begin with '{'.  Got %d(%@)", c, [JavaLangCharacter valueOfWithUnichar:(unichar) c]]] autorelease];
  }
  while (YES) {
    c = [self nextNonWhitespace];
    switch (c) {
      NSString *key;
      case '}':
      return object;
      case '"':
      case '\'':
      [self backWithInt:c];
      key = [self nextStringWithInt:c];
      if ([self nextNonWhitespace] != ':') {
        @throw [[[EMJsonException alloc] initWithNSString:@"Invalid object: expecting \":\""] autorelease];
      }
      [((id<EMJsonObject>) NIL_CHK(object)) putWithNSString:key withEMJsonValue:[self nextValue]];
      switch ([self nextNonWhitespace]) {
        case ',':
        break;
        case '}':
        return object;
        default:
        @throw [[[EMJsonException alloc] initWithNSString:@"Invalid object: expecting } or ,"] autorelease];
      }
      break;
      case ',':
      break;
      default:
      if (lenient_ && ([JavaLangCharacter isDigitWithUnichar:(unichar) c] || [JavaLangCharacter isLetterOrDigitWithUnichar:(unichar) c])) {
        JavaLangStringBuffer *keyBuffer = [[[JavaLangStringBuffer alloc] init] autorelease];
        [((JavaLangStringBuffer *) NIL_CHK(keyBuffer)) appendWithInt:c];
        while (YES) {
          c = [self next];
          if ([JavaLangCharacter isDigitWithUnichar:(unichar) c] || [JavaLangCharacter isLetterOrDigitWithUnichar:(unichar) c]) {
            [((JavaLangStringBuffer *) NIL_CHK(keyBuffer)) appendWithInt:c];
          }
          else {
            [self backWithInt:c];
            break;
          }
        }
        if ([self nextNonWhitespace] != ':') {
          @throw [[[EMJsonException alloc] initWithNSString:@"Invalid object: expecting \":\""] autorelease];
        }
        [((id<EMJsonObject>) NIL_CHK(object)) putWithNSString:[((JavaLangStringBuffer *) NIL_CHK(keyBuffer)) description] withEMJsonValue:[self nextValue]];
        switch ([self nextNonWhitespace]) {
          case ',':
          break;
          case '}':
          return object;
          default:
          @throw [[[EMJsonException alloc] initWithNSString:@"Invalid object: expecting } or ,"] autorelease];
        }
      }
      else {
        @throw [[[EMJsonException alloc] initWithNSString:@"Invalid object: "] autorelease];
      }
    }
  }
}

- (id<EMJsonNumber>)getNumberForLiteralWithNSString:(NSString *)literal {
  @try {
    return [((id<EMJsonFactory>) NIL_CHK(jsonFactory_)) createWithDouble:[JavaLangDouble parseDoubleWithNSString:literal]];
  }
  @catch (JavaLangNumberFormatException *e) {
    @throw [[[EMJsonException alloc] initWithNSString:[NSString stringWithFormat:@"Invalid number literal: %@", literal]] autorelease];
  }
}

- (id<EMJsonValue>)getValueForLiteralWithNSString:(NSString *)literal {
  if ([@"" isEqual:literal]) {
    @throw [[[EMJsonException alloc] initWithNSString:@"Missing value"] autorelease];
  }
  if ([@"null" isEqual:literal] || [@"undefined" isEqual:literal]) {
    return [((id<EMJsonFactory>) NIL_CHK(jsonFactory_)) createNull];
  }
  if ([@"true" isEqual:literal]) {
    return [((id<EMJsonFactory>) NIL_CHK(jsonFactory_)) createWithBOOL:YES];
  }
  if ([@"false" isEqual:literal]) {
    return [((id<EMJsonFactory>) NIL_CHK(jsonFactory_)) createWithBOOL:NO];
  }
  unichar c = [NIL_CHK(literal) charAtWithInt:0];
  if (c == '-' || [JavaLangCharacter isDigitWithUnichar:c]) {
    return [self getNumberForLiteralWithNSString:literal];
  }
  @throw [[[EMJsonException alloc] initWithNSString:[NSString stringWithFormat:@"Invalid literal: \"%@\"", literal]] autorelease];
}

- (int)readWithJavaLangCharacterArray:(IOSCharArray *)buffer
                              withInt:(int)pos
                              withInt:(int)len {
  int maxLen = [JavaLangMath minWithInt:[NIL_CHK(json_) length] - position_ withInt:len];
  NSString *src = [NIL_CHK(json_) substring:position_ endIndex:position_ + maxLen];
  IOSCharArray *result = [NIL_CHK(src) toCharArray];
  [JavaLangSystem arraycopyWithId:result withInt:0 withId:buffer withInt:pos withInt:maxLen];
  position_ += maxLen;
  return maxLen;
}

- (void)dealloc {
  JreOperatorRetainedAssign(&json_, nil);
  JreOperatorRetainedAssign(&jsonFactory_, nil);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  ElementalJsonImplJsonTokenizer *typedCopy = (ElementalJsonImplJsonTokenizer *) copy;
  typedCopy.jsonFactory = jsonFactory_;
  typedCopy.lenient = lenient_;
  typedCopy.pushBackBuffer = pushBackBuffer_;
  typedCopy.json = json_;
  typedCopy.position = position_;
}

@end
